#include <iostream>#include <SDL/SDL.h>#include <stdint.h>#include "camera.h"#include "../util/debug.h"#include "../sprites/sprites.h"#include "../sprites/babar.h"#include "../sprites/monsters.h"#include "../sprites/projectiles.h"#include "../video/statics.h"#include "../game/static_data.h"#include "../util/globals.h"#include "../events/events_manager.h"#include "../events/events.h"Camera::Camera(){	m_target = NULL;	m_screen = NULL;	m_decalage.x = 0;	m_decalage.y = 0;	m_direction.x = 0;	m_direction.y = 0;}Camera::~Camera(){	PRINT_CONSTR(1, "Destruction de la camera")	PRINT_TRACE(1, "Fermeture de la fenetre")	SDL_FreeSurface(m_screen);	PRINT_TRACE(1, "Fermeture de la SDL")	SDL_Quit();}void Camera::init_camera(Sprite *target){	SDL_Rect position_target = target->position();	PRINT_CONSTR(1, "Construction de la camera")	PRINT_TRACE(1, "Initialisation de la SDL")	if (SDL_Init(SDL_INIT_VIDEO) == -1) {		PRINT_DEBUG(1, "Erreur d'initialisation de la SDL")		return;	}	m_frame.h = WINDOW_HEIGHT;	m_frame.w = WINDOW_WEIGHT;	m_frame.x = position_target.x + (position_target.w / 2) - (m_frame.w / 2);	m_frame.y = position_target.y + (position_target.h / 2) - (m_frame.h / 2);	PRINT_TRACE(1, "Ouverture de la fenetre (de taille %d*%d)", m_frame.h, m_frame.w)	m_screen = SDL_SetVideoMode(m_frame.w, m_frame.h, 32, SDL_HWSURFACE | SDL_DOUBLEBUF /*| SDL_FULLSCREEN*/);	SDL_WM_SetCaption("SuperBabar", NULL);	m_target = target;}void Camera::update_decalage(){	//mise Ã  jour de la direction du decalage	if (m_target->direction_h() != 0) {		m_direction.x = m_target->direction_h();	}	if (m_target->direction_v() != 0) {		m_direction.y = m_target->direction_v();	}			// gestion du decalage horizontal	m_decalage.x += m_direction.x* VITESSE_DECALAGE_CAMERA;	if (m_decalage.x < -m_frame.w *MAX_DECALAGE_CAMERA)		m_decalage.x = -m_frame.w * MAX_DECALAGE_CAMERA;	if (m_decalage.x > m_frame.w * MAX_DECALAGE_CAMERA)		m_decalage.x = m_frame.w * MAX_DECALAGE_CAMERA;			// gestion du decalage vertical	if(m_target->direction_v() == 0) {		if (m_decalage.y > 0) {			if (m_decalage.y < VITESSE_DECALAGE_RETOUR_CAMERA)				m_decalage.y = 0;			else				m_decalage.y -= VITESSE_DECALAGE_RETOUR_CAMERA;		} else {			if (m_decalage.y > -VITESSE_DECALAGE_RETOUR_CAMERA)				m_decalage.y = 0;			else				m_decalage.y += VITESSE_DECALAGE_RETOUR_CAMERA;						}		} else {		m_decalage.y += (m_target)->direction_v()* VITESSE_DECALAGE_CAMERA;		if (m_decalage.y < -m_frame.h *MAX_DECALAGE_CAMERA)			m_decalage.y = -m_frame.h * MAX_DECALAGE_CAMERA;		if (m_decalage.y > m_frame.h * MAX_DECALAGE_CAMERA)			m_decalage.y = m_frame.h * MAX_DECALAGE_CAMERA;		}}void Camera::update_pos(Static_data *static_data){	update_decalage();	SDL_Rect position_target = m_target->position();	m_frame.x = position_target.x + (position_target.w / 2) - (m_frame.w / 2);	m_frame.x += m_decalage.x;	m_frame.y = position_target.y + (position_target.h / 2) - (m_frame.h / 2);	m_frame.y += m_decalage.y;	if (m_frame.x < 0)		m_frame.x = 0;	if (m_frame.y < 0)		m_frame.y = 0;	if ((uint32_t) (m_frame.x + m_frame.w) > static_data->static_data_weight())		m_frame.x = static_data->static_data_weight() - m_frame.w;	if ((uint32_t) (m_frame.y + m_frame.h) > static_data->static_data_height())		m_frame.y = static_data->static_data_height() - m_frame.h;}
void Camera::display_background(SDL_Surface *background){	SDL_Rect pos;	//~ pos = m_target->position();	//~ pos.x = -pos.x * BACKGROUND_SPEED;	//~ pos.y = -pos.y * BACKGROUND_SPEED;	pos.x = - m_frame.x  * BACKGROUND_SPEED;	pos.y = - m_frame.y * BACKGROUND_SPEED;	SDL_BlitSurface(background, NULL, m_screen, &pos);}void Camera::display_sprite(Sprite *sprite){	SDL_Surface *picture = sprite->current_picture();	if (picture != NULL) {		SDL_Rect pos_sprite = sprite->position();		pos_sprite.x -= m_frame.x;		pos_sprite.y -= m_frame.y;		SDL_BlitSurface(picture, NULL, m_screen, &pos_sprite);	}}

void Camera::display_static(Static *sttc)
{
    SDL_Rect pos_static = sttc->position();
    pos_static.x -= m_frame.x;
	pos_static.y -= m_frame.y;
    SDL_BlitSurface(sttc->image(), NULL, m_screen, &pos_static);
}
void Camera::display_events(Events_manager *event_manager){	event_manager->display_events(this);}
void Camera::display_event(Event *event){	SDL_Surface *picture = event->current_picture();	if (picture != NULL) {		SDL_Rect pos_event = event->current_pos();		pos_event.x -= m_frame.x;		pos_event.y -= m_frame.y;		SDL_BlitSurface(picture, NULL, m_screen, &pos_event);	}	}SDL_Rect Camera::frame(){	return m_frame;}void Camera::display_picture(SDL_Surface *pic, SDL_Rect *pos){	SDL_BlitSurface(pic, NULL, m_screen, pos);}
void Camera::flip_camera(){	SDL_Flip(m_screen);}