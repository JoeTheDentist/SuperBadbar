
#include <cmath>
#include "AI_node.h"

AI_node::AI_node(Sprite * target, Collisions_manager * context,
            std::list<Rect*> * proj, int depth, int precision, Rect * dim, AI_node * daddy)
{
    m_target = target;
    m_context = context;
    m_proj = proj;
    m_precision = precision;
    m_depth = depth;
    m_dim = dim;

    m_daddy = daddy;
}

bool AI_node::is_solution()
{
    if ( m_daddy == NULL ) {
        return false;
    }

    if (m_depth==m_precision) {
        return true;
    }

    bool sol = false;
    for (std::list<Rect *>::iterator it = m_proj->begin();
				it != m_proj->end() && !sol; it++) {
        sol = sol||check_collision(*m_dim,**it);
    }

    return sol;
}

int AI_node::depth()
{
    return m_depth;
}

Rect AI_node::dim()
{
    return *m_dim;
}

AI_node * AI_node::daddy()
{
    return m_daddy;
}

bool AI_node::maybe_best(Node * n)
{
    if ( n == NULL ) {
        return true;
    }

    return evaluation() <= n->evaluation();
}

std::list<Node*> * AI_node::divide()
{
    /* Attention, ici c'est juste pour les monstres qui marchent, marche pas pour volants, faire avec polymph */
    /* On suppose qu'on a toujours les 4 possibilités */

    std::list<Node*> * l = new std::list<Node*>;

    Rect * lz = new Rect;
    Rect * rz = new Rect;
    Rect * uz = new Rect;
    Rect * dz = new Rect;
    *lz = *rz = *uz = *dz = *m_dim;
    lz->x -= m_dim->w;
    rz->x += m_dim->w;
    uz->y -= m_dim->h;
    dz->y += m_dim->h;

    /* calcul des nouveaux blocs */

    if ( is_solution() ) {
        return NULL;
    }

    if ( m_dim->x > m_target->position().x ) {
        /* si on est à droite de la cible */
        /* d'abord à gauche */
        /* ici on ne teste pas collision gauche : TODO */
        add_node(l,lz);
        /* saut et descente */
        if ( Collisions_manager::is_down_coll(m_context->down_collision_type(*m_dim)) ) {
            /* si on a une collision en dessous, on peut sauter */
            add_node(l,uz);
        }
        if ( !m_context->double_collision(*m_dim) ) {
            /* si on peut passer par en desssous */
            add_node(l,dz);
        }
        /* enfin à droite */
        /* idem gauche, TODO */
        add_node(l,rz);
    } else {
        /* si on est à gauche de la cible */
        /* d'abord à droite */
        /* ici on ne teste pas collision droite : TODO */
        add_node(l,rz);
        /* saut et descente */
        if (Collisions_manager::is_down_coll(m_context->down_collision_type(*m_dim)) ) {
            /* si on a une collision en dessous, on peut sauter */
            add_node(l,uz);
        }
        if ( !m_context->double_collision(*m_dim) ) {
            /* si on peut passer par en desssous */
            add_node(l,dz);
        }
        /* enfin à gauche*/
        /* idem droite, TODO */
        add_node(l,lz);
    }

    return l;
}

void AI_node::add_node(std::list<Node*> * l, Rect * z) {
    /* TODO : avoir les vraies dimensions du niveau
    passer par le collision_manager => collision_matrix... */
    if ( z->x > 0 && z->y-z->h > 0 ) {
        /* si la zone n'est pas en dehors de la carte */
        AI_node * n = new AI_node(m_target,m_context,m_proj,m_depth+1,m_precision,z,this);
        l->push_front(n);
    }
}

double AI_node::evaluation()
{
    /* pondération /r à la profondeur */
    double dist_weight = 1/dist(*m_dim,m_target->position())/m_depth;

    double proj_weight = 0;

    /* si on a des projectiles dans la case... */
    for (std::list<Rect *>::iterator it = m_proj->begin();
				it != m_proj->end(); it++) {
        proj_weight -= 20000/dist(*m_dim,**it); /* coef à changer TODO, il faut qu'il compense dist*/
    }

    /* favoriser le fait d'être au dessus du joueur */
    double jump_weight = 0;
    if ( m_dim->y < m_target->position().y ) {
        jump_weight += 10;
    }

    return dist_weight+proj_weight+jump_weight;
}

double AI_node::dist(Rect A, Rect B)
{
    return sqrt( (A.x-B.x)*(A.x-B.x) + (A.y-B.y)*(A.y-B.y) );
}

bool AI_node::check_collision(Rect A, Rect B)
{
	uint16_t A_right = A.x + A.w;
	uint16_t B_right = B.x + B.w;
	uint16_t A_bottom = A.y + A.h;
	uint16_t B_bottom = B.y + B.h;
	bool A_in_B = ((B.x < A.x && A.x < B_right) || (B.x < A_right && A_right < B_right )) && ((B.y < A.y && A.y < B_bottom) || (B.y < A_bottom && A_bottom < B_bottom ));
	bool B_in_A = ((A.x < B.x && B.x < A_right) || (A.x < B_right && B_right < A_right )) && ((A.y < B.y && B.y < A_bottom) || (A.y < B_bottom && B_bottom < A_bottom ));
	return A_in_B || B_in_A;
}

